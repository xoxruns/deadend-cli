
# Copyright (C) 2025 Yassine Bargach
# Licensed under the GNU Affero General Public License v3
# See LICENSE file for full license information.

"""Web exploitation agent for automated vulnerability testing and exploitation.

This module implements an AI agent that performs automated exploitation of
web application vulnerabilities, including injection attacks, authentication
bypasses, and other common web security issues.
"""

from typing import Any
from pydantic import BaseModel
from pydantic_ai import Tool
from pydantic_ai.usage import Usage, UsageLimits

from .factory import AgentRunner
from deadend_cli.core.models import AIModel
from deadend_cli.core.tools import (
    sandboxed_shell_tool, 
    is_valid_request, 
    send_payload
)
from deadend_cli.prompts import render_agent_instructions, render_tool_description

class ExploitOutput(BaseModel):
    reasoning: str
    payload: str
    result: str


class ExploitAgent(AgentRunner):
    """
    
    """
    
    def __init__(
            self, 
            model: AIModel,  
            deps_type: Any | None, 
            target_information: str
        ):
        
        tools_metadata = {
            "is_valid_request": render_tool_description("is_valid_request"),
            "send_payload": render_tool_description("send_payload"),
            "sandboxed_shell_tool": render_tool_description("sandboxed_shell_tool"),        
        } 
        self.instructions = render_agent_instructions(
            agent_name="exploit_web",
            tools=tools_metadata,
            target=target_information
        )
        super().__init__(
            name="exploit_web", 
            model=model, 
            instructions=self.instructions, 
            deps_type=deps_type,
            output_type=ExploitOutput, 
            tools=[
                Tool(is_valid_request),
                Tool(send_payload),
                Tool(sandboxed_shell_tool),
            ]
        )
    

    async def run(self, user_prompt, deps, message_history, usage, usage_limits):
        return await super().run(user_prompt, deps, message_history, usage, usage_limits)